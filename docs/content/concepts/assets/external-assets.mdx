---
title: Non-Materializable Assets | Dagster
description: Non-materializable assets model assets in Dagster that are not kept up to date in Dagster.
---

# Non-Materializable Assets (Experimental)

An **non-materializable asset** is an asset that is visible in Dagster but updated by an external process. For example, you have a process that loads data from Kafka into Amazon S3 every day. You want the S3 asset to be visible alongside your other data assets, but not triggered by Dagster.

In this case, you can use a non-materializable asset to leverage Dagster's event log and tooling without using the orchestrator. This allows you to maintain data lineage, observability, and data quality without unnecessary migrations.

---

## Uses and limitations

Using non-materializable assets, you can:

- Attach metadata to asset definitions for documentation, tracking ownership, and so on
- Track the assets' [data quality](/concepts/assets/asset-checks) and [version](/guides/dagster/asset-versioning-and-caching) in Dagster
- Use [asset sensors](/concepts/partitions-schedules-sensors/asset-sensors) or auto-materialize policies to update downstream assets based on updates to external assets

### Limitations

The following aren't currently supported when using non-materializable assets:

- Scheduling the materialization of an non-materializable asset
- Backfilling a non-materializable asset using Dagster
- Using the [Dagster UI](/concepts/webserver/ui) or [GraphQL API](/concepts/webserver/graphql) to instigate ad hoc materializations

---

## Relevant APIs

| Name                                   | Description                                                        |
| -------------------------------------- | ------------------------------------------------------------------ |
| <PyObject object="AssetsDefinition" /> | A class that represents a one or more asset definitions.           |
| <PyObject object="observable_asset" /> | A decorator that defines an asset with a function that observes it |

---

## Defining non-materializable assets

The following code declares a single non-materializable asset that represents a file in S3 and passes it to a <PyObject object="Definitions"/> object:

<TabGroup>
<TabItem name="Asset definition">

Click the **Asset in the Dagster UI** tab to see how this asset would be rendered in the Dagster UI.

```python file=/concepts/assets/external_assets/single_declaration.py
from dagster import AssetsDefinition

file_in_s3 = AssetsDefinition.single("file_in_s3")
```

Like when you use the `@asset` decorator, this code results in an `AssetsDefinition` object that contains the definition of a single asset. But unlike an `AssetsDefinition` object produced by the `@asset` decorator, the resulting object does not include a materialization function for the asset.

---

</TabItem>
<TabItem name="Asset in the Dagster UI">

Click the **Asset definition** tab to view how this asset is defined.

Note that the **Materialize** button is disabled, because Dagster doesn't know how to materialize the asset.

<Image
alt="The files_in_s3 external asset in the Asset Graph of the Dagster UI"
src="/images/concepts/assets/external-asset.png"
width={3024}
height={1654}
/>

---

</TabItem>
</TabGroup>

### Non-materializable assets with dependencies

Dependencies are defined by using the `deps` argument. This enables Dagster to model entire graphs of assets scheduled and orchestrated by other systems.

In the following example, we have two assets: `raw_logs` and `processed_logs`. The `processed_logs` asset is produced by a scheduled computation in another orchestration system. Using non-materializable assets allows you to model both assets in Dagster.

<TabGroup>
<TabItem name="Asset definitions">

Click the **Assets in the Dagster UI** tab to see how these assets would be rendered in the Dagster UI.

```python file=/concepts/assets/external_assets/external_asset_deps.py
from dagster import AssetsDefinition

raw_logs = AssetsDefinition.single("raw_logs")
processed_logs = AssetsDefinition.single("processed_logs", deps=[raw_logs])
```

---

</TabItem>
<TabItem name="Assets in the Dagster UI">

Click the **Asset definitions** tab to view how these assets are defined.

Note that the **Materialize** button is disabled, because Dagster doesn't know how to materialize the asset.

<Image
alt="Non-materializable assets with dependencies in the Dagster UI"
src="/images/concepts/assets/external-assets-show-detail.png"
width={3024}
height={1654}
/>

---

</TabItem>
</TabGroup>

### Dagster-native assets with non-materializable asset dependencies

Fully-managed assets can depend on non-materializable assets. In this example, the `aggregated_logs` asset depends on `processed_logs`, which is an non-materializable asset:

<TabGroup>
<TabItem name="Asset definitions">

Click the **Assets in the Dagster UI** tab to see how these assets would be rendered in the Dagster UI.

```python file=/concepts/assets/external_assets/normal_asset_depending_on_external.py
from dagster import AssetsDefinition, asset

raw_logs = AssetsDefinition.single("raw_logs")
processed_logs = AssetsDefinition.single("processed_logs", deps=[raw_logs])


@asset(deps=[processed_logs])
def aggregated_logs() -> None:
    # Loads "processed_log" into memory and performs some aggregation
    ...
```

</TabItem>
<TabItem name="Assets in the Dagster UI">

Click the **Asset definitions** tab to view how these assets are defined.

<Image
alt="A non-materializable asset as an upstream dependency to a fully-managed asset in the Dagster UI"
src="/images/concepts/assets/external-assets-normal-dep-on-external.png"
width={3024}
height={1654}
/>

</TabItem>
</TabGroup>

---

## Events for non-materializable assets

As with materializable assets, it's often useful to track how the contents of a non-materializable asset change over time. This allows catching data reliability issues, like data quality and freshness, as well as surfacing metadata in the catalog like column schema, row count, and usage statistics. TODO: more on why you want to do this, single pane of glass, etc..

There are two ways to track metadata for a non-materializable asset:

- **Observations** - If you want to treat the process that updates the asset as a black box, but still monitor changes to the asset itself, then you can execute code within Dagster that observes the asset and reports the observation results in asset observation events.
- **External materializations** - If the asset is updated in a discrete (i.e. non-streaming) manner, and you can instrument the process that updates it, then you can report asset materialization events to Dagster whenever it's updated from within that external process.

### Observable non-materializable assets

In many cases, the process that updates an asset is opaque to Dagster. For example, an asset might be a Kafka topic, a table updated by a streaming framework, or a table kept up-to-date by a distant team within the organization. However, properties of the asset itself can still be observed.

You can use _observable assets_ to monitor these assets using Dagster. An observable asset pairs an asset definition with a function that observes the asset. The observation function is expected to return metadata that describes the asset at the time it's observed. This function can be scheduled, or manually executed, within Dagster, just like an asset materialization function.

```python
from dagster import observable_asset, ObserveResult

@observable_asset
def events():
    row_count = ...
    last_updated_timestamp = ...
    return ObserveResult(
        metadata={"row_count": row_count, "dagster/last_updated_timestamp": last_updated_timestamp}
    )
```

### Reporting external materializations for non-materializable assets

In large organizations, Dagster often lives side-by-side with other orchestrators. For assets kept up-to-date by those orchestrators, it's often possible to instrument the tasks that update them to report those materializations to Dagster. This allows Dagster to be used as a central catalog and data reliability tool, even when it's not a central orchestrator.

This offers a deeper level of observability than with asset observations, because it provides a complete record of every time the asset was updated, and offers the ability to link back to the run in the other orchestrator that updated the asset.

To record a materializations from another system, you can use any of the following approaches:

- [REST API](#using-the-rest-api)
- [Python API](#using-the-python-api)
- [Logging events using ops](#logging-events-using-ops)

#### Using the REST API

Whether you're using Dagster OSS or Dagster+, you can use a REST endpoint for reporting asset materializations. The API also has endpoints for reporting [asset observations](/concepts/assets/asset-observations) and [asset check evaluations](/concepts/assets/asset-checks).

Refer to the following tabs for examples using `curl` and Python to communicate with the API.

##### Using curl

<TabGroup>
<TabItem name="Dagster+">

```bash
curl --request POST \
    --url https://{organization}.dagster.cloud/{deployment}/report_asset_materialization/{asset_key} \
    --header 'Content-Type: application/json' \
    --header 'Dagster-Cloud-Api-Token: {token}' \
    --data '{
    "metadata" : {
        "source": "From curl command"
    }
}'
```

---

</TabItem>
<TabItem name="Dagster OSS">

```bash
curl --request POST \
    --url https://{dagster_webserver_host}/report_asset_materialization/{asset_key} \
    --header 'Content-Type: application/json' \
    --data '{
    "metadata" : {
        "source": "From curl command"
    }
}'
```

---

</TabItem>
</TabGroup>

##### Using Python

<TabGroup>
<TabItem name="Dagster+">

```python
import requests

url = f"https://{organization}.dagster.cloud/{deployment}/report_asset_materialization/{asset_key}"
payload = { "metadata": { "source": "From python script" } }
headers = { "Content-Type": "application/json", "Dagster-Cloud-Api-Token": "{token}" }

response = requests.request("POST", url, json=payload, headers=headers)
```

---

</TabItem>
<TabItem name="Dagster OSS">

```python
import requests

url = f"https://{dagster_webserver_host}/report_asset_materialization/{asset_key}"
payload = { "metadata": { "source": "From python script" } }
headers = { "Content-Type": "application/json" }

response = requests.request("POST", url, json=payload, headers=headers)
```

---

</TabItem>
</TabGroup>

#### Using the Python API

You can insert events to attach to external assets directly from Dagster's Python API. Specifically, the API is `report_runless_asset_event` on <PyObject object="DagsterInstance" />.

For example, this would be useful when writing a Python script to backfill metadata:

```python file=/concepts/assets/external_assets/external_asset_events_using_python_api.py startafter=start_python_api_marker endbefore=end_python_api_marker dedent=4
from dagster import AssetMaterialization

# instance is a DagsterInstance. Get using DagsterInstance.get()
instance.report_runless_asset_event(
    AssetMaterialization(
        "asset_one", metadata={"nrows": 10, "source": "From this script."}
    )
)
```

#### Logging events using ops

You can log an <PyObject object="AssetMaterialization"/> from an [op](/concepts/ops-jobs-graphs/ops). In this case, use the `log_event` method of <PyObject object="OpExecutionContext"/> to report an asset materialization of an external asset. For example:

```python file=/concepts/assets/external_assets/update_external_asset_via_op.py
from dagster import (
    AssetMaterialization,
    AssetsDefinition,
    Definitions,
    OpExecutionContext,
    job,
    op,
)


@op
def an_op(context: OpExecutionContext) -> None:
    context.log_event(AssetMaterialization(asset_key="external_asset"))


@job
def a_job() -> None:
    an_op()


defs = Definitions(assets=[AssetsDefinition.single("external_asset")], jobs=[a_job])
```

---

## Related

<ArticleList>
  <ArticleListItem
    title="Software-defined Assets"
    href="/concepts/assets-software-defined-assets"
  ></ArticleListItem>
  <ArticleListItem
    title="Asset sensors"
    href="/concepts/partitions-schedules-sensors/asset-sensors"
  ></ArticleListItem>
  <ArticleListItem
    title="Asset checks"
    href="/concepts/assets/asset-checks"
  ></ArticleListItem>
  <ArticleListItem
    title="Asset observations"
    href="/concepts/assets/asset-observations"
  ></ArticleListItem>
</ArticleList>
